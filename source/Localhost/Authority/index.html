<!DOCTYPE html>
<html>
	<head>
		
			<title>Localhost::Authority</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		
		<script src="../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../index.html">Project</a> › <a class="link" href="../../index.html">Source</a></header>
		
		<main>
			
	<h1><code class="language-ruby">Localhost::Authority</code></h1>
	
	<p>Represents a single public/private key pair for a given hostname.</p>
	
	
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="Localhost::Authority.list"><h3><code class="language-ruby">def self.list(root = self.path)</code></h3><p>List all certificate authorities in the given directory:</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def self.list(root = self.path)
	return to_enum(:list) unless block_given?
	
	Dir.glob(&quot;*.crt&quot;, base: root) do |path|
		name = File.basename(path, &quot;.crt&quot;)
		
		authority = self.new(name, root: root)
		
		if authority.load
			yield authority
		end
	end
end</code></pre>
					</details></section><section id="Localhost::Authority.fetch"><h3><code class="language-ruby">def self.fetch(*arguments, **options)</code></h3><p>Fetch (load or create) a certificate with the given hostname.
See <code class="language-ruby">#initialize</code> for the format of the arguments.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def self.fetch(*arguments, **options)
	authority = self.new(*arguments, **options)
	
	unless authority.load
		authority.save
	end
	
	return authority
end</code></pre>
					</details></section><section id="Localhost::Authority#initialize"><h3><code class="language-ruby">def initialize(hostname = &quot;localhost&quot;, root: self.class.path)</code></h3><p>Create an authority forn the given hostname.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>parameter</strong>　<code class="syntax">hostname</code>　<code class="language-ruby">String</code></dt><dd><p>The common name to use for the certificate.</p>
</dd><dt>
					<strong>parameter</strong>　<code class="syntax">root</code>　<code class="language-ruby">String</code></dt><dd><p>The root path for loading and saving the certificate.</p>
</dd></dl>
</details>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def initialize(hostname = &quot;localhost&quot;, root: self.class.path)
	@root = root
	@hostname = hostname
	
	@key = nil
	@name = nil
	@certificate = nil
	@store = nil
end</code></pre>
					</details></section><section id="Localhost::Authority#hostname"><h3><code class="language-ruby">attr :hostname</code></h3><p>The hostname of the certificate authority.</p>
</section><section id="Localhost::Authority#key_path"><h3><code class="language-ruby">def key_path</code></h3><p>The private key path.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def key_path
	File.join(@root, &quot;#{@hostname}.key&quot;)
end</code></pre>
					</details></section><section id="Localhost::Authority#certificate_path"><h3><code class="language-ruby">def certificate_path</code></h3><p>The public certificate path.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def certificate_path
	File.join(@root, &quot;#{@hostname}.crt&quot;)
end</code></pre>
					</details></section><section id="Localhost::Authority#key"><h3><code class="language-ruby">def key</code></h3><p>The private key.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def key
	@key ||= OpenSSL::PKey::RSA.new(BITS)
end</code></pre>
					</details></section><section id="Localhost::Authority#name"><h3><code class="language-ruby">def name</code></h3><p>The certificate name.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def name
	@name ||= OpenSSL::X509::Name.parse(&quot;/O=Development/CN=#{@hostname}&quot;)
end</code></pre>
					</details></section><section id="Localhost::Authority#certificate"><h3><code class="language-ruby">def certificate</code></h3><p>The public certificate.</p>
<details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">OpenSSL::X509::Certificate</code></dt><dd><p>A self-signed certificate.</p>
</dd></dl>
</details>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def certificate
	@certificate ||= OpenSSL::X509::Certificate.new.tap do |certificate|
		certificate.subject = self.name
		# We use the same issuer as the subject, which makes this certificate self-signed:
		certificate.issuer = self.name
		
		certificate.public_key = self.key.public_key
		
		certificate.serial = 1
		certificate.version = 2
		
		certificate.not_before = Time.now
		certificate.not_after = Time.now + (3600 * 24 * 365 * 10)
		
		extension_factory = OpenSSL::X509::ExtensionFactory.new
		extension_factory.subject_certificate = certificate
		extension_factory.issuer_certificate = certificate
		
		certificate.extensions = [
			extension_factory.create_extension(&quot;basicConstraints&quot;, &quot;CA:FALSE&quot;, true),
			extension_factory.create_extension(&quot;subjectKeyIdentifier&quot;, &quot;hash&quot;),
		]
		
		certificate.add_extension extension_factory.create_extension(&quot;authorityKeyIdentifier&quot;, &quot;keyid:always,issuer:always&quot;)
		certificate.add_extension extension_factory.create_extension(&quot;subjectAltName&quot;, &quot;DNS: #{@hostname}&quot;)
		
		certificate.sign self.key, OpenSSL::Digest::SHA256.new
	end
end</code></pre>
					</details></section><section id="Localhost::Authority#store"><h3><code class="language-ruby">def store</code></h3><p>The certificate store which is used for validating the server certificate.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def store
	@store ||= OpenSSL::X509::Store.new.tap do |store|
		store.add_cert(self.certificate)
	end
end</code></pre>
					</details></section><section id="Localhost::Authority#server_context"><h3><code class="language-ruby">def server_context(*arguments)</code></h3><details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">OpenSSL::SSL::SSLContext</code></dt><dd><p>An context suitable for implementing a secure server.</p>
</dd></dl>
</details>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def server_context(*arguments)
	OpenSSL::SSL::SSLContext.new(*arguments).tap do |context|
		context.key = self.key
		context.cert = self.certificate
		
		context.session_id_context = &quot;localhost&quot;
		
		if context.respond_to? :tmp_dh_callback=
			context.tmp_dh_callback = proc {self.dh_key}
		end
		
		if context.respond_to? :ecdh_curves=
			context.ecdh_curves = 'P-256:P-384:P-521'
		elsif context.respond_to? :tmp_ecdh_callback=
			context.tmp_ecdh_callback = proc {self.ecdh_key}
		end
		
		context.set_params(
			ciphers: SERVER_CIPHERS,
			verify_mode: OpenSSL::SSL::VERIFY_NONE,
		)
	end
end</code></pre>
					</details></section><section id="Localhost::Authority#client_context"><h3><code class="language-ruby">def client_context(*args)</code></h3><details open>
	<summary><h4>Signature</h4></summary>
	<dl><dt>
					<strong>returns</strong>　<code class="language-ruby">OpenSSL::SSL::SSLContext</code></dt><dd><p>An context suitable for connecting to a secure server using this authority.</p>
</dd></dl>
</details>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def client_context(*args)
	OpenSSL::SSL::SSLContext.new(*args).tap do |context|
		context.cert_store = self.store
		
		context.set_params(
			verify_mode: OpenSSL::SSL::VERIFY_PEER,
		)
	end
end</code></pre>
					</details></section>	</section>
	
	

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>